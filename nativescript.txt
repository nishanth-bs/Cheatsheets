import { Component } from "@angular/core";

@Component({
  selector: "gr-login",
  templateUrl: "login/login.component.html"
})
export class AppComponent {}

<ActionBar title="Groceries"></ActionBar>
<StackLayout>
  <TextField hint="Email Address" keyboardType="email"
    autocorrect="false" autocapitalizationType="none"></TextField>
  <TextField hint="Password" secure="true"></TextField>
  <Button text="Sign in"></Button>
  <Button text="Sign up for Groceries"></Button>
</StackLayout>


<TextField>
hint: Shows placeholder text that tells the user what to type.
keyboardType: The type of keyboard to present to the user for input. keyboardType="email" shows a keyboard optimized for entering email addresses. 
autocorrect: A boolean attribute that determines whether the mobile operating system should autocorrect user input. In the case of email address text fields, the autocorrect behavior is undesirable.
autocapitalizationType: Determines how the operating system should autocapitalize user input. autocapitalizationType="none" turns autocapitalization off altogether. NativeScript supports four autocapitalization types on text fields.
secure: A boolean attribute that determines whether the text field’s text should be masked, which is commonly done on password fields.
<Button>
text: Controls the text displayed within the button.

Next, let’s focus on the other new UI component in the above example—<StackLayout>—and discuss how to organize your UI components in NativeScript apps.

Because NativeScript does not use a browser to render UI components, web layout concepts like display: block and display: inline do not work in NativeScript apps.
Instead, NativeScript provides several different layout UI components that allow you to position your components using native Android and iOS layout mechanisms. Although there are several layout containers in NativeScript, there are three you’ll primarily use.

The <StackLayout> lets you stack child UI elements either vertically or horizontally.
The <GridLayout> lets you divide your interface into a series of rows and columns, much like a <table> in HTML markup.
The <FlexboxLayout> lets you arrange UI components using the syntax as display: flex on web.

<ActionBar title="Groceries"></ActionBar>
<FlexboxLayout>
	<StackLayout>
		<TextField hint="Email Address" keyboardType="email" autocorrect="false" autocapitalizationType="none"></TextField>
		<TextField hint="Password" secure="true"></TextField>

		<Button text="Sign in"></Button>
    <Button text="Sign up for Groceries"></Button>
  </StackLayout>
</FlexboxLayout>

The <StackLayout> is the simplest NativeScript layout, as all it does is stack user interface components—vertically by default, and horizontally if you give the component a orientation="horizontal" attribute.
The other layout component in this example is the <FlexboxLayout> control. With a <FlexboxLayout> you have the ability to align components using the same flexbox syntax you would use to align <div> in a web app. Flexbox is commonly used for vertical centering, and that’s exactly what you’re going to use it for in this tutorial.


Step 3. Styling your app using CSS
import { Component } from "@angular/core";

@Component({
  selector: "gr-login",
  templateUrl: "login/login.component.html",
  styleUrls: ["login/login.component.css"]
})
export class AppComponent {}

login.component.css
FlexboxLayout {
  justify-content: center;
  align-items: center;
  background-size: cover;
  background-image: url("~/images/background.jpg");
}
StackLayout {
  width: 300;
  padding: 10 16;
  background-color: #f0f0f0;
}

Step 4. Using the NativeScript Core theme
NativeScript’s styling infrastructure makes it possible to create and use CSS themes for your native applications, much like you would use a framework like Bootstrap on the web.
The NativeScript project provides a core theme that you can add to any of your projects. The theme includes two color schemes, light and dark, as well as a series of convenience class names to help you build elegant user interfaces quickly.

Open your app/app.css file and paste in the following code, which imports the NativeScript Core theme’s default stylesheet.

@import "~nativescript-theme-core/css/core.light.css";

ActionBar {
  background-color: black;
  color: white;
}

In NativeScript, the app.css is a global stylesheet. Any rules you apply in app.css apply to all components in your app.
The <ActionBar> colors look a little odd on this page at the moment; don’t worry though, you’ll fix this display later in this tutorial. You can learn more about using the <ActionBar> component on its documentation page.

Open your app/login/login.component.html file and replace its contents with the following code, which adds a new class attribute to several of the UI components.

<ActionBar title="Groceries"></ActionBar>

<FlexboxLayout>
  <StackLayout class="form">
    <TextField hint="Email Address" keyboardType="email"
      autocorrect="false" autocapitalizationType="none"
      class="input input-border"></TextField>
    <TextField hint="Password" secure="true"
      class="input input-border"></TextField>

    <Button text="Sign in" class="btn btn-primary"></Button>
    <Button text="Sign up for Groceries"></Button>
  </StackLayout>
</FlexboxLayout>

c. Open your app/login/login.component.css file, and add the following CSS code under the existing selectors.

Image {
  margin-bottom: 20;
  height: 70;
}
Button, TextField {
  margin-bottom: 10;
}
.btn-primary {
  background-color: #CB1D00;
  margin-left: 0;
  margin-right: 0;
}
TextField {
  placeholder-color: #C4AFB4;
  color: black;
}

The first thing to note here are the class names form, input, input-border, btn, and btn-primary. These are all class names from the NativeScript Core Theme, and each apply a set of CSS rules to help your UI components look good by default.

Step 5. Working with images in your app
In NativeScript you use the <Image> UI element and its src attribute to add images to your pages. The src attribute lets you specify your image in three ways. The first (and simplest) way is to point at the URL of an image:
<Image src="https://www.nativescript.org/images/default-source/landingpages/logo.png"></Image>
The second way is to point at an image that lives within your app's app folder. For example if you have an image at app/images/logo.png, you can use it with:
<Image src="~/images/logo.png"></Image>
The third way is to use platform-specific image resources, which you can learn more about on the NativeScript documentation. Let’s add a logo images to the Groceries app so you can see how this works.

Open your app’s app/login/login.component.html file, and replace the component’s template with the following code, which adds a new <Image> component.
<ActionBar title="Groceries"></ActionBar>

<FlexboxLayout>
  <StackLayout class="form">
    <Image src="~/images/logo.png"></Image>

    <TextField hint="Email Address" keyboardType="email"
      autocorrect="false" autocapitalizationType="none"
      class="input input-border"></TextField>
    <TextField hint="Password" secure="true"
      class="input input-border"></TextField>

    <Button text="Sign in" class="btn btn-primary"></Button>
    <Button text="Sign up for Groceries"></Button>
  </StackLayout>
</FlexboxLayout>


Lesson 2. Adding Application Logic
In this lesson you’ll learn how to add TypeScript logic to your app, how to create services that talk to backend endpoints, and how to architect an app to share code with Angular web apps.
Step 6. Handling events
Most user interfaces are driven by events. In NativeScript apps, those events are usually some user action, such as tapping, swiping, or rotating. NativeScript abstracts the iOS- and Android-specific code for handling such events into a handful of easy-to-use APIs. 
Let’s start with the most common event you’ll use in a NativeScript app: tap.
 Open your app/login/login.component.html file, find the existing sign in button within your component’s template 
 (<Button text="Sign in" class="btn btn-primary"></Button>), 
 and replace it with the following code.
<Button text="Sign in" class="btn btn-primary" (tap)="submit()"></Button>
b. Next, open your app/app.component.ts file, and replace the current AppComponent declaration (export class AppComponent {}) with the one shown below.

export class AppComponent {
  submit() {
    console.log("hello");
  }
}


Step 7. Binding to data
Angular provides several ways to bind data in your TypeScript code to UI controls, and through the magic of NativeScript those same methods are available in your iOS and Android apps.

The first of these is a way to bind UI attributes to properties defined in your TypeScript class. 
In your app/app.component.ts file, replace the current AppComponent declaration with the one shown below, which adds a new email property, and changes the submit() method to display its value:

export class AppComponent {
  email = "nativescriptrocks@progress.com";
  submit() {
    alert("You’re using: " + this.email);
  }
}

b. Next, open your app/login/login.component.html file, find the first <TextField>, and replace it with the code below, which adds a new text attribute.

<TextField hint="Email Address" keyboardType="email"
  autocorrect="false" autocapitalizationType="none"
  [text]="email" class="input input-border"></TextField>

  Next, let’s look at how to implement two-way binding in an Angular app.
Open your app/login/login.component.html file, find the first <TextField>, and replace it with the <TextField> below, which introduces a new [(ngModel)] attribute:

<TextField hint="Email Address" keyboardType="email"
  autocorrect="false" autocapitalizationType="none"
  [(ngModel)]="email" class="input input-border"></TextField>

  b. Next, open your app/app.module.ts file, and replaces its contents with the code below, which adds a new NativeScriptFormsModule to the NgModule’s list of imports.

import { NgModule } from "@angular/core";
import { NativeScriptFormsModule } from "nativescript-angular/forms";
import { NativeScriptModule } from "nativescript-angular/nativescript.module";

import { AppComponent } from "./app.component";

@NgModule({
  imports: [
    NativeScriptModule,
    NativeScriptFormsModule
  ],
  declarations: [AppComponent],
  bootstrap: [AppComponent]
})
export class AppModule {}

In the case of this example, [(ngModel)]="email" is shorthand for [text]="email" (textChange)="email=$event.object.text", which binds the email element’s text attribute to an email property and adds a change event handler that updates the email property’s value whenever the user makes a change.

Before we move on, let’s make one additional change to show what else you can do with Angular’s data binding APIs. The Groceries app uses the same UI for the Sign In form and the Sign Up form. Therefore, when the user taps Sign Up, you need to update the text of the buttons (and eventually the functionality that occurs when you tap them). Let’s see how to make that happen.

a. Open your app/login/login.component.html file and replace the two existing <Button>s with the code below.

<Button [text]="isLoggingIn ? 'Sign in' : 'Sign up'"
  class="btn btn-primary" (tap)="submit()"></Button>
<Button [text]="isLoggingIn ? 'Sign up' : 'Back to login'"
  (tap)="toggleDisplay()"></Button>
b. Next, open your app/app.component.ts file, and replace the existing AppComponent declaration with the code below, which adds a new isLoggingIn property, and a new toggleDisplay() method:

export class AppComponent {
  email = "nativescriptrocks@progress.com";
  isLoggingIn = true;

  submit() {
    alert("You’re using: " + this.email);
  }

  toggleDisplay() {
    this.isLoggingIn = !this.isLoggingIn;
  }
}

Step 8. Structuring your app
There are many reasons to segment any application into modular units, and you can read about the various benefits on Wikipedia. Modularizing NativeScript has one additional, unique benefit: the ability to share the code you write between Angular-built web apps, and Angular-built native apps.

Even if you have no plans to create an Angular web app, separating out your code is still advantageous for a number of other reasons—testability, ease of maintenance, and so forth—but if you do have plans to build an Angular web app, having a chunk of functionality that you can reuse in your native and web apps can be an invaluable time saver.

a. Open your app/shared/user/user.model.ts file, and paste in the following code.

export class User {
  email: string;
  password: string;
}
b. Next, open your app/app.component.ts file and add the following import at the top.

import { User } from "./shared/user/user.model";
With this line of code you import the User class that you just defined. Note the parallel between the export command used in the previous example and the import command used here. The reason the User class is available to import is because it was explicitly exported. You’ll see other examples of import and export as you go through this guide.

c. While still in app/app.component.ts, replace the existing AppComponent definition with the one below, which uses the User class you just imported.
export class AppComponent {
  user: User;
  isLoggingIn = true;
  constructor() {
    this.user = new User();
  }
  submit() {
    alert("You’re using: " + this.user.email);
  }

  toggleDisplay() {
    this.isLoggingIn = !this.isLoggingIn;
  }
}

d. Your last step is to use this new model object in your template. To do that, open your app/login/login.component.html file, and replace the two existing <TextField>s with the code shown below, which updates the [(ngModel)] bindings to point at the new User object:

<TextField hint="Email Address" keyboardType="email"
  autocorrect="false" autocapitalizationType="none"
  [(ngModel)]="user.email" class="input input-border"></TextField>
<TextField hint="Password" secure="true"
  [(ngModel)]="user.password" class="input input-border"></TextField>

  With this setup you now have a User class that you can share across pages in your app and even across applications. But a model object that’s four lines of code isn’t all that exciting. Where this approach really pays off is when you’re able to share your business logic, and the code that hits your backend systems. In Angular those classes are known as services. Let’s look at them next.

Step 9. Building services
A login screen isn’t all that useful if it doesn’t actually log users into anything. Therefore, our next task is to allow users to create and log into accounts. We’ll build this functionality as an Angular service, which is Angular’s mechanism for reusable classes that operate on data.

a. Open your app/shared/user/user.service.ts file and paste in the following code, which defines a simple register() method.

import { Injectable } from "@angular/core";

import { User } from "./user.model";

@Injectable()
export class UserService {
  register(user: User) {
    alert("About to register: " + user.email);
  }
}
b. Next, add the following line to the top of your app/app.component.ts file, which imports the service you just defined.
import { UserService } from "./shared/user/user.service";
c. After that, in the same app.component.ts file, add a new providers property to the existing @Component decorator. The full @Component declaration should now look like this.

@Component({
  selector: "gr-login",
  providers: [UserService],
  styleUrls: ["login/login.component.css"],
  templateUrl: "login/login.component.html"
})
The providers array is a simple list of all the Angular services that you need to use in your component. 
At the moment you only have one service, so your providers array only has one entry.
d. Next, replace AppComponent’s existing constructor with the code below, which adds the new UserService as a parameter. (We’ll discuss exactly what’s going on here in a moment.)

constructor(private userService: UserService) {
  this.user = new User();
}
e. After that, remove the existing submit() method in your AppComponent class. (You’ll add a new one in the next step.)

f. Finally, add the the following three methods to your AppComponent class.


submit() {
  if (this.isLoggingIn) {
    this.login();
  } else {
    this.signUp();
  }
}

login() {
  // TODO: Define
}

signUp() {
  this.userService.register(this.user);
}

Before we move on, let’s return to this bit of code.


constructor(private userService: UserService) {
  this.user = new User();
}
This is Angular’s dependency injection implementation in action. Because you registered UserService as a provider in this component’s providers array, when Angular sees this syntax it creates an instance of the UserService class, and passes that instance into the component’s constructor.


Let’s return to our example and make the registration process actually work.

ACTION
a. Open your app/shared/user/user.service.ts file and replaces its contents with the following code, which we’ll discuss in detail in a moment.

import { Injectable } from "@angular/core";
import { Http, Headers, Response } from "@angular/http";
import { Observable } from "rxjs";
import { catchError, map, tap } from "rxjs/operators";

import { User } from "./user.model";
import { Config } from "../config";

@Injectable()
export class UserService {
    constructor(private http: Http) { }

    register(user: User) {
        return this.http.post(
            Config.apiUrl + "user/" + Config.appKey,
            JSON.stringify({
                username: user.email,
                email: user.email,
                password: user.password
            }),
            { headers: this.getCommonHeaders() }
        ).pipe(
            catchError(this.handleErrors)
        );
    }

    getCommonHeaders() {
        let headers = new Headers();
        headers.append("Content-Type", "application/json");
        headers.append("Authorization", Config.authHeader);
        return headers;
    }

    handleErrors(error: Response) {
        console.log(JSON.stringify(error.json()));
        return Observable.throw(error);
    }
}
b. Next, open your app/app.component.ts file, and replace the existing signUp() function with the following code.

signUp() {
  this.userService.register(this.user)
    .subscribe(
      () => {
        alert("Your account was successfully created.");
        this.toggleDisplay();
      },
      () => alert("Unfortunately we were unable to create your account.")
    );
}

The first thing to note here is the new constructor code in user.service.ts.


constructor(private http: Http) {}
The UserService class is using the same dependency injection technique to bring in a service that it needs, in this case the Http class, which is Angular’s way of letting you perform HTTP calls. And thanks to NativeScript, those same HTTP APIs work on iOS and Android without any extra work.
he other new bit of code is the return value of this new register() method. register() returns this.http.post(), which is an RxJS Observable.

The two functions you pass subscribe() are success and failure handlers. If the call to register() succeeds, your first alert will fire, and if the call to register() fails, your second alert will fire. Now that your service code is set up and ready to go, let’s make the final few changes and create an account.

he () => {} syntax defines an ES2015 arrow function, which TypeScript supports out of the box. In this example, the arrow functions are the equivalent of writing function() {}. Arrow functions have the advantage of inheriting their context—aka this—from their parents. Note how the code above is able to call this.toggleDisplay() from an inner function, which would not work with a generic JavaScript function() {}.

Because the UserService makes use of the Http service, your final step is registering the Http provider, much like you did with UserService. Although you could do this in your app.component.ts file, this time you’re going to take a slightly different approach.

a. Open your app/app.module.ts file and replace its contents with the following code, which adds a new NativeScriptHttpModule to the list of imports.
import { NgModule } from "@angular/core";
import { NativeScriptFormsModule } from "nativescript-angular/forms";
import { NativeScriptHttpModule } from "nativescript-angular/http";
import { NativeScriptModule } from "nativescript-angular/nativescript.module";

import { AppComponent } from "./app.component";

@NgModule({
  imports: [
    NativeScriptModule,
    NativeScriptFormsModule,
    NativeScriptHttpModule
  ],
  declarations: [AppComponent],
  bootstrap: [AppComponent]
})
export class AppModule {}

NativeScriptHttpModule is a NativeScript wrapper of Angular’s HttpModule, a module that declares all of Angular’s HTTP-based services—including the Http service that UserService uses.

Step 10. Add navigation with routing
Most of the Angular concepts you’ve used in the last few sections are the same regardless of whether you’re building for the web or native apps. You are even able to share model objects and services directly between the two environments.

Routing is similar, but there are some differences. Routing on the web revolves around the concept of a URL, but in a native app there is no browser. Likewise, native apps have concepts that aren’t present in the browser, such as Android’s hardware back button, or iOS’s swipe left-to-right gesture to go back.

Let’s look at how NativeScript handles this by implementing routing in Groceries.
To this point you’ve been putting your login page code in app.component.ts. Let’s move that logic into the login folder to make room for additional pages.

a. Open your app/app.component.ts file, and copy its contents into your app/login/login.component.ts file.

b. Next, in your new app/login/login.component.ts file, change the name of the class from AppComponent to LoginComponent.

c. After that, in the same file, update the two broken User and UserService imports to use the code below.


import { User } from "../shared/user/user.model";
import { UserService } from "../shared/user/user.service";
d. Next, open your app/app.routing.ts file and paste in the following code.

import { LoginComponent } from "./login/login.component";

export const routes = [
  { path: "", component: LoginComponent }
];

export const navigatableComponents = [
  LoginComponent
];
The app/app.routing.ts file is where you declare a list of all your app’s routes. Right now your routes array has a single route for the login page, but you’ll add more momentarily. To get this app running you need to make two more changes.

e. Open your app/app.module.ts file, and replace the file’s contents with the following code, which adds a new NativeScriptRouterModule import, as well as imports the routes you just declared in app.routing.ts.

import { NgModule } from "@angular/core";
import { NativeScriptFormsModule } from "nativescript-angular/forms";
import { NativeScriptHttpModule } from "nativescript-angular/http";
import { NativeScriptModule } from "nativescript-angular/nativescript.module";
import { NativeScriptRouterModule } from "nativescript-angular/router";

import { AppComponent } from "./app.component";
import { routes, navigatableComponents } from "./app.routing";

@NgModule({
  imports: [
    NativeScriptModule,
    NativeScriptFormsModule,
    NativeScriptHttpModule,
    NativeScriptRouterModule,
    NativeScriptRouterModule.forRoot(routes)
  ],
  declarations: [
    AppComponent,
    ...navigatableComponents
  ],
  bootstrap: [AppComponent]
})
export class AppModule {}

An NgModule’s declarations array expects a list of the components that you’ll be using in your app. In this case you’re adding the navigatableComponents array you exported in your app.routing.ts file to the AppComponent declaration you already had. The ... operator is ES2015 spread syntax, and it’s easiest to explain what it does with a quick example. If you declare a variable x as let x = [2, 3], then JavaScript will interpret [1, ...x] as [1, 2, 3].

f. After that, open your app/app.component.ts file back up and paste in the following code. We’ll discuss this file in detail momentarily.

import { Component } from "@angular/core";

@Component({
  selector: "gr-app",
  template: "<page-router-outlet></page-router-outlet>"
})
export class AppComponent {}
g. And finally, open your app/main.ts file, and replace its contents with the following code, which removes the createFrameOnBootstrap option, as it’s no longer necessary now that you have routing in place.

import { platformNativeScriptDynamic } from "nativescript-angular/platform";
import { enableProdMode } from "@angular/core";

import { AppModule } from "./app.module";

enableProdMode();
platformNativeScriptDynamic().bootstrapModule(AppModule)

You’ve now successfully added a router, but you haven’t gotten to see it action as your app still only has one route. Let’s add a new route to Groceries to try this out.

ACTION
a. Open your app/list/list.component.ts file and paste in the following code, which you’ll use as the start of a simple list page.

import { Component } from "@angular/core";

@Component({
  selector: "gr-list",
  templateUrl: "list/list.component.html",
  styleUrls: ["list/list.component.css"]
})
export class ListComponent {}
b. For now, we’ll keep the list page simple so you can see how the routing works. But so that there’s something to see, open your app/list/list.component.html file and paste in the following <Label>.

<ActionBar title="Groceries"></ActionBar>
<Label text="Hello world"></Label>
c. After that, go back to your app/app.routing.ts file, and update the file with the following code.

import { LoginComponent } from "./login/login.component";
import { ListComponent } from "./list/list.component";

export const routes = [
  { path: "", component: LoginComponent },
  { path: "list", component: ListComponent }
];

export const navigatableComponents = [
  LoginComponent,
  ListComponent
];

Angular now knows about the list page, but we still need to navigate the user to that page at the appropriate time. Your last task for this lesson is to allow users to log into their accounts, and then to navigate them to the new list page after they have successfully authenticated.

ACTION
a. Open your app/shared/user/user.service.ts file, and add the login() function below to the existing UserService class.

login(user: User) {
    return this.http.post(
        Config.apiUrl + "user/" + Config.appKey + "/login",
        JSON.stringify({
            username: user.email,
            password: user.password
        }),
        { headers: this.getCommonHeaders() }
    ).pipe(
        map(response => response.json()),
        tap(data => {
            Config.token = data._kmd.authtoken
        }),
        catchError(this.handleErrors)
    );
}
This code hits one of this tutorial’s existing backend endpoints, and stores off an authentication token that you’ll use later in this guide.

b. To use your service’s new login() function, return to your app/login/login.component.ts file, and add the following import to the top of the file:

import { Router } from "@angular/router";
c. Next, replace the current constructor() declaration with the code below, which injects Angular’s Router service.

constructor(private router: Router, private userService: UserService) {
d. Finally, replace the LoginComponent’s existing login() function with the code below, which calls your service’s new login() method, and calls the router’s navigate() method if login() completes successfully.

login() {
  this.userService.login(this.user)
    .subscribe(
      () => this.router.navigate(["/list"]),
      (error) => alert("Unfortunately we could not find your account.")
    );
}

Step 11. Customizing UI components
So far, you’ve only used NativeScript UI elements by including them in an Angular component’s template, but you can also programatically create and access UI elements, and each UI component has a set of properties and methods you can use to customize your app.

In the next example you’re going to hide the <ActionBar> on the login page, but before doing that there are two pieces of background knowledge you need to know.

First, in NativeScript a single <Page> UI element wraps the template of every page-level Angular component. You don’t see this component, but it’s there, and it’s a UI component you can customize.

Second, on Android an <ActionBar> shows in your app even if you don’t explicitly include an <ActionBar> in your template. (The title defaults to the name of your app.) To truly hide the <ActionBar> you have to set a property of the <Page> component, and that’s exactly what you’re going to do in this next example.

ACTION
a. Open your app/login/login.component.ts file, and add the following import to the top, which adds a reference to the Page class from the NativeScript core modules.

import { Page } from "tns-core-modules/ui/page";
b. Next, alter the same file’s existing "@angular/core" import to include the OnInit interface.

import { Component, OnInit } from "@angular/core";
c. OnInit is a TypeScript class interface. To see how it works, make the following change to the declaration of your LoginComponent class.

export class LoginComponent implements OnInit {
After you add the new implements keyword, you should see an error in Playground that says something like “Class ‘LoginComponent’ incorrectly implements interface ‘OnInit’”. When you implement a TypeScript class interface, you’re telling the TypeScript compiler that you must implement all methods that the interface requires. In the case of OnInit, Angular requires you to implement a single ngOnInit() method.

d. To implement it, add the following method to your LoginComponent class.

ngOnInit() {
  this.page.actionBarHidden = true;
}

ngOnInit is one of several component lifecycle hooks that Angular provides. As its name implies, ngOnInit gets invoked when Angular initializes this component.

e. We’ll discuss what the code within ngOnInit() does momentarily, but next, to make these changes compile and run, change the LoginComponent’s existing constructor() declaration to use the code below.

constructor(private router: Router, private userService: UserService, private page: Page) {

Because the Page class is so commonly used in NativeScript apps, NativeScript provides this syntax as a shorthand for getting access to a component’s page. You’ll see other methods of getting access to UI components to change their properties later in this guide.

When your app refreshes the bar that previously appeared at the top of the screen on Android should now be hidden.
Now that you have this code in place, let’s discuss what happens on this line:


this.page.actionBarHidden = true;
This code uses an instance of the Page class from the NativeScript page module, and sets its actionBarHidden property to true, which hides the ActionBar that shows by default on Android devices.

Although you can peruse the NativeScript API documentation for a full list of these properties and what they do, if you’re using a TypeScript-friendly IDE, you can get a full list of these properties at any point. You can see this behavior in NativeScript Playground as you type this.page. while editing your login.component.ts file.

Let’s make one last change to complete your login page, and this time we’ll use some new Angular syntax.

ACTION
a. Open your app/login/login.component.html file and change the opening <StackLayout> tag to use the following code.

<StackLayout class="form" [class.dark]="!isLoggingIn">
b. Next, open your app/login/login.component.css file and add the following code to the bottom.

.dark {
  background-color: #301217;
}
.dark TextField {
  color:  #C4AFB4;
}

The [class.className] syntax is a handy Angular feature that lets you conditionally apply class names based on a boolean condition. In this case, [class.dark]="!isLoggingIn tells Angular to apply the dark class name only when the component’s isLoggingIn flag is false.

What’s even cooler is that the syntax works even if you need to apply additional CSS class names to the component. That is, when using the syntax class="form" [class.dark]="!isLoggingIn", Angular is smart enough to keep the form class name applied even as it toggles the dark class name. You might find this trick handy as you develop your NativeScript applications using Angular.

Step 12. Introducing NativeScript UI
In addition to the NativeScript core user interface components, many of which you’ve used throughout this guide, NativeScript additionally provides a collection of free, professional components collectively known as NativeScript UI.

NativeScript UI contains controls for building drawers, listviews, calendars, charts, forms, autocompletes, and more. In fact, the graph you saw back in lesson one of this tutorial was a NativeScript UI component. To show what NativeScript UI can do, let’s look at to use the suite’s listview control to start to add a grocery list to your app.

ACTION
a. Open your app’s app/list/list.component.html file and replace its contents with the following code:

<ActionBar title="Groceries"></ActionBar>

<GridLayout>
  <RadListView [items]="groceryList">
    <ng-template let-item="item">
      <Label [text]="item.name" class="p-15"></Label>
    </ng-template>
  </RadListView>
</GridLayout>
b. Next, open your app/app.module.ts file, and add the following import to the top of the file.

import { NativeScriptUIListViewModule } from "nativescript-ui-listview/angular";
c. After that, in the same app/app.module.ts file, add the NativeScriptUIListViewModule class you just imported to the @NgModule’s imports array. The array should now look like this.

imports: [
  NativeScriptModule,
  NativeScriptFormsModule,
  NativeScriptHttpModule,
  NativeScriptRouterModule,
  NativeScriptRouterModule.forRoot(routes),
  NativeScriptUIListViewModule
],
d. Finally, open your app/list/list.component.ts file and replace its contents with the code below:

import { Component, ElementRef, OnInit, ViewChild } from "@angular/core";

@Component({
  selector: "gr-list",
  templateUrl: "list/list.component.html",
  styleUrls: ["list/list.component.css"]
})
export class ListComponent implements OnInit {
  groceryList: Array<Object> = [];

  ngOnInit() {
    this.groceryList.push({ name: "Apples" });
    this.groceryList.push({ name: "Bananas" });
    this.groceryList.push({ name: "Oranges" });
  }
}
e. Save your files. When your app refreshes on your device, navigate to the list page and you should see a hardcoded grocery list.
Let’s break down what’s happening in the example above. First, your ListComponent class now has a groceryList property that you fill with three objects in an ngOnInit handler. This makes an array of hardcoded data available for your template to bind to.

Let’s break down the template next.


<RadListView [items]="groceryList">
  <ng-template let-item="item">
    <Label [text]="item.name" class="p-15"></Label>
  </ng-template>
</RadListView>
The <RadListView> pro UI element requires an items property that points to an array of data—in this case, the groceryList array you added to your ListComponent class. The list view element requires a child <ng-template> element that specifies how to render each item in the items array.

The let-* syntax is Angular’s way of creating template variables within loops. You can think of the syntax working like TypeScript’s  let keyword. This gives you the ability to refer to each item in the array as item within the template. For this template, you render each item in the array with a single <Label> UI element, and because of the [text]="item.name" binding, those labels contain the text from the name property of each of the items in groceryList TypeScript array.

Now that you have a hardcoded list of groceries displaying, let’s see how to swap that out with live data from a backend.

ACTION
a. Open your app/shared/grocery/grocery.model.ts and paste in the following code, which creates a simple Grocery model object that you can use throughout your app.

export class Grocery {
  constructor(public id: string, public name: string) {}
}
b. Next, let’s create a simple service that reads grocery lists from our backend. Open your app/shared/grocery/grocery.service.ts file and paste in the following code.

import { Injectable } from "@angular/core";
import { Http, Headers, Response, URLSearchParams } from "@angular/http";
import { Observable } from "rxjs";
import { catchError, map, tap } from "rxjs/operators";

import { Config } from "../config";
import { Grocery } from "./grocery.model";

@Injectable()
export class GroceryService {
    baseUrl = Config.apiUrl + "appdata/" + Config.appKey + "/Groceries";

    constructor(private http: Http) { }

    load() {
        // Kinvey-specific syntax to sort the groceries by last modified time. Don’t worry about the details here.
        let params = new URLSearchParams();
        params.append("sort", "{\"_kmd.lmt\": 1}");

        return this.http.get(this.baseUrl, {
            headers: this.getCommonHeaders(),
            params: params
        }).pipe(
            map(res => res.json()),
            map(data => {
                let groceryList = [];
                data.forEach((grocery) => {
                    groceryList.push(new Grocery(grocery._id, grocery.Name));
                });
                return groceryList;
            }),
            catchError(this.handleErrors)
        );
    }

    getCommonHeaders() {
        let headers = new Headers();
        headers.append("Content-Type", "application/json");
        headers.append("Authorization", "Kinvey " + Config.token);
        return headers;
    }

    handleErrors(error: Response) {
        console.log(JSON.stringify(error.json()));
        return Observable.throw(error);
    }
}
The code here is very similar to the code you used in the UserService earlier in this guide. You use the Http service’s get() method to load JSON data, and RxJS’s map() function to format the data into an array of Grocery objects.

c. To use this service, open your app/list/list.component.ts file and add the following two lines to the top of the file:

import { Grocery } from "../shared/grocery/grocery.model";
import { GroceryService } from "../shared/grocery/grocery.service";
d. Next, in the same list.component.ts file, change the existing groceryList declaration to use the newly imported Grocery class instead of a generic Object.

groceryList: Array<Grocery> = [];
e. After that, add the following constructor function within the ListComponent class.

constructor(private groceryService: GroceryService) {}
f. Because the previous line of code injects service into your constructor, you must also include it as a provider within your component decorator. To do so, replace the existing @Component decorator with the code below:

@Component({
  selector: "gr-list",
  templateUrl: "list/list.component.html",
  styleUrls: ["list/list.component.css"],
  providers: [GroceryService]
})
g. Finally, to kick off the call to your new service’s load() method, replace the ListComponent’s existing ngOnInit() method with the code below.

ngOnInit() {
  this.groceryService.load()
    .subscribe(loadedGroceries => {
      loadedGroceries.forEach((groceryObject) => {
        this.groceryList.unshift(groceryObject);
      });
    });
}
In case you got lost during this section, your full list.component.ts file should now look like this.


import { Component, ElementRef, OnInit, ViewChild } from "@angular/core";

import { Grocery } from "../shared/grocery/grocery.model";
import { GroceryService } from "../shared/grocery/grocery.service";

@Component({
  selector: "gr-list",
  templateUrl: "list/list.component.html",
  styleUrls: ["list/list.component.css"],
  providers: [GroceryService]
})
export class ListComponent implements OnInit {
  groceryList: Array<Grocery> = [];

  constructor(private groceryService: GroceryService) {}

  ngOnInit() {
    this.groceryService.load()
      .subscribe(loadedGroceries => {
        loadedGroceries.forEach((groceryObject) => {
          this.groceryList.unshift(groceryObject);
        });
      });
  }
}
h. Save your files.
When your app refreshes on your device you’ll see a blank list page, but you didn’t do anything wrong! Your app now reads grocery data from a backend, but you don’t have any groceries associated with your new account.

Step 13. Using advanced layouts
In order to allow users to add to their grocery lists, you need to add a few additional UI controls to the list page. While you could use a simple <StackLayout> to stack up the controls you need, let’s look at how to create a slightly more complex layout using the <GridLayout> element.
a. Open your app/list/list.component.html file and replace its contents with the following code:

<ActionBar title="Groceries"></ActionBar>

<GridLayout rows="auto, *">

  <GridLayout row="0" columns="*, auto" class="add-bar">
    <TextField #groceryTextField hint="Enter a grocery item" col="0"></TextField>
    <Image src="~/images/add.png" col="1"></Image>
  </GridLayout>

  <RadListView row="1" [items]="groceryList">
    <ng-template let-item="item">
      <Label [text]="item.name" class="p-15"></Label>
    </ng-template>
  </RadListView>

</GridLayout>
b. Next, open your app/list/list.component.css file and replace its contents with the following code.

.add-bar {
  background-color: #CB1D00;
  padding: 5;
}
.add-bar Image {
  height: 25;
  vertical-align: center;
  margin-left: 10;
  margin-right: 10;
}
.add-bar TextField {
  padding: 10;
}
Label {
  background-color: white;
  border-bottom-width: 1;
  border-bottom-color: gray;
}
c. Save your files. When your app refreshes with these changes on your device you should see the following UI.


Let’s break down how this layout works, starting with the outer structure of the markup.


<GridLayout rows="auto, *">
  <GridLayout row="0" class="add-bar">...</GridLayout>
  <RadListView row="1">...</RadListView>
</GridLayout>
The outer grid layout’s rows attribute divides the screen into two rows, the first auto-sized according to its childrens' height, and the other sized to take up *, or the remaining height of the screen. You place UI elements into these rows using the zero-based row attribute. The inner grid layout is in the top row because of its row="0" attribute, and the list view is in the bottom row because of its row="1" attribute.

Grid layouts can also divide the screen into columns, which is what the inner grid layout does.


<GridLayout columns="*, auto" class="add-bar">
  <TextField col="0"></TextField>
  <Image col="1"></Image>
</GridLayout>
Here the columns attribute divides the top of the screen into two columns. The col="0" attribute puts the text field in the first column, and the col="1" attribute puts the “+” image in the last column. Grid layouts are the most commonly used NativeScript layout, so you may wish to take a minute to play around with the columns and rows attributes to figure out how they work.


You can nest any of the NativeScript layouts—not just grid layouts.
You can pass numbers, percentages, and a variety of other values to create more complex grid layouts. Refer to the grid layout docs for more information.
Now that we have the UI ready, let’s make the add button work.

ACTION
a. Open your app/list/list.component.html and give the existing <TextField> a new [(ngModel)] attribute so that it looks like this:

<TextField #groceryTextField [(ngModel)]="grocery" hint="Enter a grocery item" col="0"></TextField>
b. Next, in the same file, add a new tap event binding to the image. The full <Image> should now look like this.

<Image src="~/images/add.png" (tap)="add()" col="1"></Image>
With these attributes in place, your next steps are to define a new  grocery property and add() method in your ListComponent class.

c. To do that, open your app/list/list.component.ts file and add the following two properties to the ListComponent class (right below the existing groceryList property):

grocery = "";
@ViewChild("groceryTextField") groceryTextField: ElementRef;
d. Next, add the following import to the top of the same list.component.ts file.

import { TextField } from "tns-core-modules/ui/text-field";
e. After that, add the following add() method to the existing ListComponent class:

add() {
  if (this.grocery.trim() === "") {
    alert("Enter a grocery item");
    return;
  }

  // Dismiss the keyboard
  let textField = <TextField>this.groceryTextField.nativeElement;
  textField.dismissSoftInput();

  this.groceryService.add(this.grocery)
    .subscribe(
      groceryObject => {
        this.groceryList.unshift(groceryObject);
        this.grocery = "";
      },
      () => {
        alert({
          message: "An error occurred while adding an item to your list.",
          okButtonText: "OK"
        });
        this.grocery = "";
      }
    )
}
In this function you first ensure the user didn’t submit without typing a grocery. If the user did type something, you dismiss the device’s keyboard with the TextField element’s dismissSoftInput() method, and then call a new add() method on the GroceryService.

f. To finish this example you have to define that new add() method. To do so, open your app/shared/grocery/grocery.service.ts file and paste the following function into the GroceryService class.

add(name: string) {
    return this.http.post(
        this.baseUrl,
        JSON.stringify({ Name: name }),
        { headers: this.getCommonHeaders() }
    ).pipe(
        map(res => res.json()),
        map(data => {
            return new Grocery(data._id, name);
        }),
        catchError(this.handleErrors)
    );
}
g. Save your files. When your app refreshes on your device you can now add grocery items and see them immediately appear in your list—and, all of this is completely driven by a backend service. Pretty cool, huh?


The add() code you used before should look familiar. You’re again using the Http service’s post() method to make an HTTP call to our backend, and then using RxJS’s map() function to convert the returned data into a Grocery object.

You consume that object in the ListComponent’s add() method, which adds the grocery to the page’s list by calling this.groceryList.unshift(), and then empties that page’s text field by setting this.grocery equal to "".


this.groceryService.add(this.grocery)
  .subscribe(
    groceryObject => {
      this.groceryList.unshift(groceryObject);
      this.grocery = "";
    },
    () => { ... }
  );
At this point you’ve come a long way. You have a functional login screen and now a backend-driven list that you can add to. Before you finish this tutorial you have a few more tasks though. Let’s start by allowing users to delete from the list, and then move on to add a loading indicator and some animations.

tep 14. Customizing NativeScript UI components
NativeScript UI is a set of professional user interface components that includes a full charting library. As such, there are a tons of functionality you can use to enhance your applications.

In this step you’ll leverage one feature of the <RadListView> control, which you’ll use to allow users to delete groceries, and learn how to find out more about the NativeScript UI controls.
ACTION
a. Open your app/list/list.component.html file, and replace the entire <RadListView> component with the code you see below. Don’t worry about the details of what’s going on at the moment; we’ll break this down momentarily.

<RadListView row="1" [items]="groceryList"
  swipeActions="true" (itemSwipeProgressStarted)="onSwipeCellStarted($event)">

  <ng-template let-item="item">
    <Label [text]="item.name" class="p-15"></Label>
  </ng-template>

  <GridLayout *tkListItemSwipeTemplate columns="*, auto">
    <StackLayout id="delete-view" col="1" (tap)="delete($event)" class="delete-view">
      <Image src="~/images/delete.png"></Image>
    </StackLayout>
  </GridLayout>

</RadListView>
b. Next, in your app/list/list.component.css file, add the following CSS to the bottom of the file.

.delete-view {
  background-color: #CB1D00;
  padding: 20;
}
.delete-view Image {
  color: white;
}
c. After that, open your app/list/list.component.ts file and add the following new imports to the top.

import { ListViewEventData, RadListView } from "nativescript-ui-listview";
import { View } from "tns-core-modules/ui/core/view";
d. With those imports in place, in the same app/list/list.component.ts file, add the following two methods to the ListComponent class.

onSwipeCellStarted(args: ListViewEventData) {
  var swipeLimits = args.data.swipeLimits;
  var swipeView = args.object;
  var rightItem = swipeView.getViewById<View>("delete-view");
  swipeLimits.right = rightItem.getMeasuredWidth();
  swipeLimits.left = 0;
  swipeLimits.threshold = rightItem.getMeasuredWidth() / 2;
}

delete(args: ListViewEventData) {
  let grocery = <Grocery>args.object.bindingContext;
  this.groceryService.delete(grocery.id)
    .subscribe(() => {
      let index = this.groceryList.indexOf(grocery);
      this.groceryList.splice(index, 1);
    });
}
e. Finally, open your app/shared/grocery/grocery.service.ts and add the following method to the GroceryService class, which hits this tutorial’s backend endpoint to delete grocery items.

delete(id: string) {
    return this.http.delete(
        this.baseUrl + "/" + id,
        { headers: this.getCommonHeaders() }
    ).pipe(
        map(res => res.json()),
        catchError (this.handleErrors)
    );
}
f. Save your files. When your device updates with these changes, you should now be able to swipe on individual items on your list and tap a button to delete them.


The NativeScript UI components have a ton of features that you can use to add powerful functionality to your applications. In the previous example you used the RadListView’s swipe action capability, which allows users to swipe on list items to perform actions.

 DETAILS ON USING SWIPE ACTIONS
To understand how this works, let’s start back with the opening <RadListView> tag from your markup.


<RadListView row="1" [items]="groceryList" [class.visible]="listLoaded"
  swipeActions="true" (itemSwipeProgressStarted)="onSwipeCellStarted($event)">
Setting the swipeActions attribute to true is necessary to turn on the <RadListView>’s swipe behavior. From there, the control triggers a number of events you can subscribe to configure exactly what you want to happen during swipes.

The only event you must subscribe to is the itemSwipeProgressStarted event, as you have to set a few values that control exactly how the swipe will work. With that in mind let’s look at your onSwipeCellStarted method and what it does.


onSwipeCellStarted(args: ListViewEventData) {
  var swipeLimits = args.data.swipeLimits;
  var swipeView = args.object;
  var rightItem = swipeView.getViewById<View>("delete-view");
  swipeLimits.right = rightItem.getMeasuredWidth();
  swipeLimits.left = 0;
  swipeLimits.threshold = rightItem.getMeasuredWidth() / 2;
}
The key here are the three lines of code at the bottom that set right, left, and threshold values. These values control the distance the user should be able to swipe right, swipe left, and the offset beyond which the swiped item will dock open, respectively.

In this example you’re saying the user should be able to swipe right for a distance that’s equal to the width of the delete button, that the user shouldn’t be able to swipe left, and that the user should be able to swipe half the width of the delete button before the button stays open.


Another popular way to configure swipe functionality is to perform an action automatically on swipe, without requiring the user to explicitly tap a button. The <RadListView> control supports this approach, and you read more about it on the NativeScript UI documentation on the topic.

Collapse
Now that users can both add and delete groceries from a list, let’s finish up this tutorial by adding a little polish to this list page.
